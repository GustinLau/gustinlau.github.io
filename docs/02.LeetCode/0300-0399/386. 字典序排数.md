---
id: 9030800F9EE9FB30
title: 386、字典序排数
date: 2022-04-24 17:37:24
permalink: /leetcode/lexicographical-numbers
link: https://leetcode-cn.com/problems/lexicographical-numbers
toc: false
categories:
  - LeetCode
tags:
  - 深度优先搜索
  - 字典树
---

<Level type='medium'/>

## 题目

给你一个整数 `n` ，按字典序返回范围 `[1, n]` 内所有整数。

你必须设计一个时间复杂度为 `O(n)` 且使用 `O(1)` 额外空间的算法。

## 示例

示例 1：

```text
输入：n = 13
输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
```

示例 2：

```text
输入：n = 2
输出：[1,2]
```

## 提示

- 1 <= n <= 5 \* 10<sup>4</sup>

## 分析

对于一个整数 `number` ，它的下一个字典序整数有以下规则：

- 当 `number * 10 <= n` ， 下一个字典序整数即为 `number * 10`
- 当 `number * 10 > n` 且 `number + 1 <= n` , 下一个字典序整数即为 `number + 1`

使用深度优先搜索的方法，记录当前前缀 `prefix` ，尝试对 `prefix * 10 + i (0 <= i<= 9)`操作，如果小于 `n` ，则以此为前缀，进行下一层搜索。

由于题目要求不使用额外空间，虽然 `n` 的最大值为 <code>5 \* 10<sup>4</sup></code>，递归深度不会超过 5 层，但严格来说不符合题目要求，可以使用迭代去代替递归，迭代方式为满足规则一，则使用规则一，否则使用规则二，规则二当 `+1` 的次数多于 `9` 或者 `+1` 后大于 `n` ，则回退 `1` 位。

## 解答

:::: code-group
::: code-group-item 递归

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var lexicalOrder = function (n) {
  const ans = []
  const dfs = (prefix) => {
    if (prefix > n) return
    for (let i = 0; i < 10; i++) {
      const a = prefix * 10 + i
      if (a <= n) {
        ans.push(a)
        dfs(a)
      }
    }
  }
  for (let i = 1; i <= Math.min(9, n); i++) {
    ans.push(i)
    dfs(i)
  }
  return ans
}
```

:::
::: code-group-item 迭代

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var lexicalOrder = function (n) {
  const ans = []
  let number = 1
  for (let i = 0; i < n; i++) {
    ans.push(number)
    if (number * 10 <= n) {
      number *= 10
    } else {
      // 末尾加到9或者加1后大于n，回退1位
      while (number % 10 === 9 || number + 1 > n) {
        number = Math.floor(number / 10)
      }
      number++
    }
  }
  return ans
}
```

:::
::::
