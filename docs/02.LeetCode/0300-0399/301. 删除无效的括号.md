---
id: CFDEDED35C13432B
title: 301、删除无效的括号
date: 2022-04-24 09:37:27
permalink: /leetcode/remove-invalid-parentheses
link: https://leetcode-cn.com/problems/remove-invalid-parentheses
toc: false
categories:
  - LeetCode
tags:
  - 广度优先搜索
  - 字符串
  - 回溯
---

<Level type='hard'/>

## 题目

给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 **任意顺序** 返回。

## 示例

示例 1：

```text
输入：s = "()())()"
输出：["(())()","()()()"]
```

示例 2：

```text
输入：s = "(a)())()"
输出：["(a())()","(a)()()"]
```

示例 3：

```text
输入：s = ")("
输出：[""]
```

# 提示

- 1 <= s.length <= 25
- s 由小写英文字母以及括号 '(' 和 ')' 组成
- s 中至多含 20 个括号

## 分析

删除最小数量的无效括号，从删除 `0` 个开始一直增加，找出结果。首先要新增一个方法判断字符串的括号是否有效，找出删除 `i` 个括号后的可能子字符串，寻找是否有合适结果，没有则找出删除 `i+1` 个括号的子字符串，判断里面是否有合适结果，如此类推。本质是广度优先搜索，该算法复杂度虽然很高，但数据量比较少，所以不会超时。

## 解答

```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function (s) {
  const set = new Set()
  const isValidParentheses = (str) => {
    let match = 0
    for (let i = 0; i < str.length; i++) {
      if (str[i] === '(') {
        match++
      } else if (str[i] === ')') {
        match--
      }
      if (match < 0) {
        return false
      }
    }
    return match === 0
  }
  if (isValidParentheses(s)) {
    return [s]
  }

  const bfs = (strs) => {
    for (let i = 0; i < strs.length; i++) {
      if (isValidParentheses(strs[i])) {
        set.add(strs[i])
      }
    }

    if (set.size === 0) {
      const sub = new Set()
      for (let i = 0; i < strs.length; i++) {
        const str = strs[i]
        for (let j = 0; j < str.length; j++) {
          if (str[j] === '(' || str[j] === ')') {
            sub.add(str.substring(0, j) + str.substring(j + 1))
          }
        }
      }
      bfs(Array.from(sub))
    }
  }
  bfs([s])
  return Array.from(set)
}
```
