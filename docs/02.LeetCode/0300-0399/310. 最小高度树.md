---
id: ACFD15A638F6F28E
title: 310、最小高度树
date: 2022-04-24 09:48:37
permalink: /leetcode/minimum-height-trees
link: https://leetcode-cn.com/problems/minimum-height-trees
toc: false
categories:
  - LeetCode
tags:
  - 深度优先搜索
  - 广度优先搜索
  - 图
  - 拓扑排序
---

<Level type='medium'/>

## 题目

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 `n` 个节点的树，标记为 `0` 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 <code>edges[i]
= [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为 **最小高度树** 。

请你找到所有的 **最小高度树** 并按 **任意顺序** 返回它们的根节点标签列表。

树的 **高度** 是指根节点和叶子节点之间最长向下路径上边的数量。

## 示例

示例 1：

![示例 1](/img/leetcode/0300-0399/310.1.png)

```text
输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
```

示例 2：

![示例 2](/img/leetcode/0300-0399/310.2.png)

```text
输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
```

## 提示

- 1 <= n <= 2 \* 10<sup>4</sup>
- edges.length == n - 1
- 0 <= a<sub>i</sub>, b<sub>i</sub> < n
- a<sub>i</sub> != b<sub>i</sub>
- 所有 (a<sub>i</sub>, b<sub>i</sub>) 互不相同
- 给定的输入 **保证** 是一棵树，并且 **不会有重复的边**

## 分析

度为 `1` 的节点都为叶子节点，除了特殊情况外（`1` 个或 `2` 个节点），叶子节点不可能是答案，[官解](https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f/)
中有证明最小高度树它们的根节点是在最长距离的中间。可以从外部往内剪掉叶子，知道最终剩下的即为答案。可参考[最容易理解的 bfs，分析简单，注释详细](https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-rong-yi-li-jie-de-bfsfen-xi-jian-dan-zhu-shi-x/)

## 解答

```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var findMinHeightTrees = function (n, edges) {
  let ans = []
  if (n === 1) {
    ans.push(0)
    return ans
  }
  const map = new Map()
  for (let i = 0; i < n; i++) {
    map.set(i, [])
  }
  const degree = new Array(n).fill(0)
  for (const edge of edges) {
    degree[edge[0]]++
    degree[edge[1]]++
    map.get(edge[0]).push(edge[1])
    map.get(edge[1]).push(edge[0])
  }
  const queue = []
  for (let i = 0; i < n; i++) {
    if (degree[i] === 1) {
      queue.push(i)
    }
  }
  while (queue.length) {
    ans = []
    const length = queue.length
    for (let i = 0; i < length; i++) {
      const cur = queue.shift()
      ans.push(cur)
      const next = map.get(cur)
      for (const nextElement of next) {
        degree[nextElement]--
        if (degree[nextElement] === 1) {
          queue.push(nextElement)
        }
      }
    }
  }
  return ans
}
```
