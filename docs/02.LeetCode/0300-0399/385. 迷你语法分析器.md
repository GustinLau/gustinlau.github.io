---
id: 883E1E842A0C88F5
title: 385、迷你语法分析器
date: 2022-04-24 17:37:24
permalink: /leetcode/mini-parser
link: https://leetcode-cn.com/problems/mini-parser
toc: false
categories:
  - LeetCode
tags:
  - 栈
  - 深度优先搜索
  - 字符串
---

<Level type='medium'/>

## 题目

给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 `NestedInteger` 。

列表中的每个元素只可能是整数或整数嵌套列表

## 示例

示例 1：

```text
输入：s = "324",
输出：324
解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。
```

示例 2：

```text
输入：s = "[123,[456,[789]]]",
输出：[123,[456,[789]]]
解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：
1. 一个 integer 包含值 123
2. 一个包含两个元素的嵌套列表：
   i.  一个 integer 包含值 456
   ii. 一个包含一个元素的嵌套列表
   a. 一个 integer 包含值 789
```

## 提示

- 1 <= s.length <= 5 \* 10<sup>4</sup>
- s 由数字、方括号 "[]"、负号 '-' 、逗号 ','组成
- 用例保证 s 是可解析的 NestedInteger
- 输入中的所有值的范围是 [-10<sup>6</sup>, 10<sup>6</sup>]

## 分析

题目本身并不难，难点在于理解`NestedInteger`对象究竟是放什么的,`NestedInteger`实际上里面放的是数字**或**数组，这里的数字是`NestedInteger`包裹住的数字，数组是`NestedInteger`通过多次`add`操作的结果，无论是数字还是数组，最终都是`NestedInteger`对象。使用栈或者递归遍历字符串。

- 遇到`'['`就新建一个`NestedInteger`对象，遇到数字则储存起来；
- 遇到`','`则将当前储存的数字放入栈顶的`NestedInteger`对象，清空存记录；
- 遇到`']'`时，如果有记录数字，将数字放入栈顶的`NestedInteger`对象中，清空记录，栈顶出栈后放入此时的栈顶`NestedInteger`对象中，若栈被清空，实际上已经是遍历完了，可以直接返回结果。

## 解答

```javascript
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a single integer equal to value.
 *     @return {void}
 *     this.setInteger = function(value) {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
 *     @return {void}
 *     this.add = function(elem) {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @param {string} s
 * @return {NestedInteger}
 */
var deserialize = function (s) {
  const stack = []
  let num = ''
  let ans
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '[') {
      stack.push(new NestedInteger())
    } else if (s[i] === ',') {
      if (num) {
        stack[stack.length - 1].add(new NestedInteger(+num))
        num = ''
      }
    } else if (s[i] === ']') {
      const item = stack.pop()
      if (num !== '') {
        item.add(new NestedInteger(+num))
        num = ''
      }
      if (stack.length) {
        stack[stack.length - 1].add(item)
      } else {
        ans = item
      }
    } else {
      num += s[i]
    }
  }
  return num ? new NestedInteger(+num) : ans
}
```
