---
id: 6105A0CDF0D17483
title: 372、超级次方
date: 2022-04-24 13:57:42
permalink: /leetcode/super-pow
link: https://leetcode-cn.com/problems/super-pow
toc: false
categories:
  - LeetCode
tags:
  - 数学
  - 分治
---

<Level type='medium'/>

## 题目

你的任务是计算 <code>a<sup>b</sup></code> 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。

## 示例

示例 1：

```text
输入：a = 2, b = [3]
输出：8
```

示例 2：

```text
输入：a = 2, b = [1,0]
输出：1024
```

示例 3：

```text
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
```

示例 4：

```text
输入：a = 2147483647, b = [2,0,0]
输出：1198
```

## 提示

- 1 <= a <= 2<sup>31</sup> - 1
- 1 <= b.length <= 2000
- 0 <= b[i] <= 9
- b 不含前导 0
-

## 分析

取余的运算规则与基本四则运算相似，`(a * b) % p = (a % p * b % p) % p`，`a ^ b % p = ((a % p) ^ b) % p`。

可以递归拆分为更小的数，后再算最终结果，这个方法是 `2` 为底的幂运算。

由于 `b` 是以数组形式给出，可以利用这个性质，进行以 `10` 为底的幂运算，从而减少大量计算量。

## 解答

:::: code-group
::: code-group-item 解法一

```javascript
/**
 * @param {number} a
 * @param {number[]} b
 * @return {number}
 */
var superPow = function (a, b) {
  const MOD = 1337
  a = a % MOD
  if (a === 0 || a === 1 || (b.length === 1 && b[0] === 1)) {
    return a
  }
  let ans = 1
  if (b[b.length - 1] % 2 === 1) {
    // 基数
    ans = a
    b[b.length - 1]--
  }
  const sub = []
  let t = 0
  for (let i = 0; i < b.length; i++) {
    let bit = Math.floor((b[i] + t * 10) / 2)
    if (i !== 0 || bit !== 0) {
      sub.push(Math.floor((b[i] + t * 10) / 2))
    }
    t = (b[i] + t * 10) % 2
  }
  return (ans * Math.pow(superPow(a, sub), 2)) % MOD
}
```

:::
::: code-group-item 解法二

```javascript
/**
 * @param {number} a
 * @param {number[]} b
 * @return {number}
 */
var superPow = function (a, b) {
  const MOD = 1337
  const dfs = (a, b, pos) => {
    if (pos === -1) {
      return 1
    }
    return (pow(dfs(a, b, pos - 1), 10) * pow(a, b[pos])) % MOD
  }
  const pow = (a, b) => {
    let ans = 1
    a %= MOD
    while (b-- > 0) {
      ans = (ans * a) % MOD
    }
    return ans
  }
  return dfs(a, b, b.length - 1)
}
```

:::
::::
