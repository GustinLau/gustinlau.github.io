---
id: 833F56D160E93D0F
title: 432、全 O(1) 的数据结构
date: 2022-04-25 14:54:15
permalink: /leetcode/all-oone-data-structure
link: https://leetcode-cn.com/problems/all-oone-data-structure
toc: false
categories:
  - LeetCode
tags:
  - 设计
  - 哈希表
  - 链表
  - 双向链表
---

<Level type='hard'/>

## 题目

请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。

实现 `AllOne` 类：

- `AllOne()` 初始化数据结构的对象。
- `inc(String key)` 字符串 `key` 的计数增加 `1` 。如果数据结构中尚不存在 `key` ，那么插入计数为 `1` 的 `key` 。
- `dec(String key)` 字符串 `key` 的计数减少 `1` 。如果 `key` 的计数在减少后为 `0` ，那么需要将这个 `key` 从数据结构中删除。测试用例保证：在减少计数前，`key` 存在于数据结构中。
- `getMaxKey()` 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 `""` 。
- `getMinKey()` 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 `""` 。

## 示例

示例：

```text
输入
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
输出
[null, null, null, "hello", "hello", null, "hello", "leet"]

解释
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "hello"
allOne.inc("leet");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "leet"
```

## 提示

- 1 <= key.length <= 10
- key 由小写英文字母组成
- 测试用例保证：在每次调用 dec 时，数据结构中总存在 key 最多调用 inc、dec、getMaxKey 和 getMinKey 方法 5 \* 10<sup>4</sup> 次

## 分析

使用双向链表，链表节点内部有一个统计变量 `cnt` 记录节点存放的 `key` 所插入的次数，一个 `set` 记录该次数插入的 `key` 值，链表前后各有一个哨兵，同时使用 `map` 记录对应 `key` 所在的节点信息，插入时，找出当前 `key` 所在节点，如果存在，则进行后移操作，如果后一个节点为尾部哨兵节点，则新建插入一个节点，如果不存在，则插入到 `cnt` 等于 `1` 的位置，删除同理，如果 `cnt` 是 `1`，则直接从 `map` 中移除，同时，插入或删除后需要清空 `key` 值为 `0` 的节点。

## 解答

```javascript
var Node = function () {
  this.set = new Set()
  this.left = null
  this.right = null
  this.cnt = 0
}

var AllOne = function () {
  this.map = new Map()
  this.head = new Node()
  this.tail = new Node()
  this.head.right = this.tail
  this.tail.left = this.head
}

/**
 *
 * @param {Node} node
 */
AllOne.prototype.clear = function (node) {
  if (node.set.size === 0) {
    node.right.left = node.left
    node.left.right = node.right
  }
}

/**
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.inc = function (key) {
  if (this.map.has(key)) {
    const node = this.map.get(key)
    node.set.delete(key)
    const cnt = node.cnt
    let next
    if (node.right.cnt === cnt + 1) {
      next = node.right
    } else {
      next = new Node()
      next.cnt = cnt + 1
      next.right = node.right
      next.right.left = next
      next.left = node
      node.right = next
    }
    next.set.add(key)
    this.map.set(key, next)
    this.clear(node)
  } else {
    let node
    if (this.head.right.cnt === 1) {
      node = this.head.right
    } else {
      node = new Node()
      node.cnt = 1
      node.right = this.head.right
      node.right.left = node
      node.left = this.head
      this.head.right = node
    }
    node.set.add(key)
    this.map.set(key, node)
  }
}

/**
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.dec = function (key) {
  const node = this.map.get(key)
  node.set.delete(key)
  const cnt = node.cnt
  if (cnt === 1) {
    this.map.delete(key)
  } else {
    let pre
    if (node.left.cnt === cnt - 1) {
      pre = node.left
    } else {
      pre = new Node()
      pre.cnt = cnt - 1
      pre.right = node
      pre.left = node.left
      pre.left.right = pre
      node.left = pre
    }
    pre.set.add(key)
    this.map.set(key, pre)
  }
  this.clear(node)
}

/**
 * @return {string}
 */
AllOne.prototype.getMaxKey = function () {
  const node = this.tail.left
  for (let v of node.set.values()) {
    return v
  }
  return ''
}

/**
 * @return {string}
 */
AllOne.prototype.getMinKey = function () {
  const node = this.head.right
  for (let v of node.set.values()) {
    return v
  }
  return ''
}

/**
 * Your AllOne object will be instantiated and called as such:
 * var obj = new AllOne()
 * obj.inc(key)
 * obj.dec(key)
 * var param_3 = obj.getMaxKey()
 * var param_4 = obj.getMinKey()
 */
```
