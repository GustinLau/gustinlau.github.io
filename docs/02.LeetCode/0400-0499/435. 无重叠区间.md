---
id: 8E4D74237CE43CD9
title: 435、无重叠区间
date: 2022-04-25 14:54:15
permalink: /leetcode/non-overlapping-intervals
link: https://leetcode-cn.com/problems/non-overlapping-intervals
toc: false
categories:
  - LeetCode
tags:
  - 贪心
  - 数组
  - 动态规划
  - 排序
---

<Level type='medium'/>

## 题目

给定一个区间的集合  `intervals` ，其中 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。返回 需要移除区间的最小数量，使剩余区间互不重叠  。

## 示例

示例 1:

```text
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

示例 2:

```text
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

示例 3:

```text
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

## 分析

按照区间的右边界进行排序，从左边开始遍历：当元素左边界大于等于前面的右边界时，更新非交叉区间的个数，从左向右进行遍历，是优先考量右边界小的区间，这样右侧剩余空间更大，可能容纳更多的区间。最后得出最多不重复的区间数，用原来区间数减做最多不重复区间数即为结果。

## 解答

```javascript
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function (intervals) {
  intervals = intervals.sort((a, b) => a[1] - b[1])
  let end = intervals[0][1]
  let count = 1
  for (let i = 1; i < intervals.length; i++) {
    const interval = intervals[i]
    if (end <= interval[0]) {
      end = interval[1]
      count++
    }
  }
  return intervals.length - count
}
```
