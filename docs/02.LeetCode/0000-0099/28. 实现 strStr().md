---
id: B92FC17FB2D98366
title: 28、实现 strStr()
date: 2022-01-09 21:58:01
permalink: /leetcode/implement-strstr
link: https://leetcode-cn.com/problems/implement-strstr
toc: false
categories:
  - LeetCode
tags:
  - 双指针
  - 字符串
  - 字符串匹配
---

<Level type='easy'/>

## 题目

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 `-1` 。

**说明：**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strStr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](<https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)>) 定义相符。

## 示例

示例 1：

```text
输入：haystack = "hello", needle = "ll"
输出：2
```

示例 2：

```text
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

示例 3：

```text
输入：haystack = "", needle = ""
输出：0
```

## 提示

- 0 <= haystack.length, needle.length <= 5 \* 10<sup>4</sup>
- haystack 和 needle 仅由小写英文字符组成

## 分析

朴素思路比较简单，直接遍历查找即可。这个题目引出了一个知识点：KMP 算法。

KMP 核心是构造 next 数组，next 数组记录的是当前长度的最大前后缀的值，遍历原串时，遇到一致时，原串跟对比串指针同时右移，当遇到字符不一致时，如果之前出现过一致的前后缀，那么，比较的指针不必回到首位，而是回退前后缀长度个数，因为前缀字符已经比较过了，无需再次比较。

计算最大前后缀长度实际上是一道动态规划的题目(求给出特定字符串的最大前后缀)，理解了 next 的构造逻辑，后面的应该不难理解，此处就不做过多讲述，后续再整理一篇文章讲述。

## 解答

:::: code-group
::: code-group-item 暴力

```javascript
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function (haystack, needle) {
  let ans = 0
  if (needle.length === 0) {
    return ans
  }
  for (let i = 0; i < haystack.length; i++) {
    if (haystack[i] === needle[0]) {
      let match = true
      for (let j = 0; j < needle.length; j++) {
        if (i + j === haystack.length) {
          return -1
        }
        if (haystack[i + j] !== needle[j]) {
          match = false
          break
        }
      }
      if (match) {
        return i
      }
    }
  }
  return -1
}
```

:::
::: code-group-item KMP

```javascript
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function (haystack, needle) {
  const h = haystack.length
  const n = needle.length
  if (!n) {
    return 0
  }
  // 构建next
  const next = new Array(n).fill(0)
  for (let j = 0, i = 1; i < n; i++) {
    while (j > 0 && needle[i] !== needle[j]) {
      j = next[j - 1]
    }
    if (needle[i] === needle[j]) {
      j++
    }
    next[i] = j
  }
  for (let i = 0, j = 0; i < h; i++) {
    while (j > 0 && needle[j] !== haystack[i]) {
      j = next[j - 1]
    }
    if (needle[j] === haystack[i]) {
      j++
    }
    if (j === n) {
      return i - (j - 1)
    }
  }
  return -1
}
```

:::
::::
