---
id: 93C5E58D73938621
title: 15、三数之和
date: 2022-01-09 21:58:01
permalink: /leetcode/3sum
link: https://leetcode-cn.com/problems/3sum
toc: false
categories:
  - LeetCode
tags:
  - 数组
  - 双指针
  - 排序
---

<Level type='medium'/>

## 题目

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 `a + b + c = 0` ？请你找出所有和为 `0` 且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。

## 示例

示例 1：

```text
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

示例 2：

```text
输入：nums = []
输出：[]
```

示例 3：

```text
输入：nums = [0]
输出：[]
```

## 提示：

- 0 <= nums.length <= 3000
- -10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>

## 分析

首先想到的思路是使用 `map` 记录数字的下标值，两次循环在 `map` 中寻找第三个数，然后利用 `set` 去重。这样相当于枚举所有可能结果，时间复杂度太大，导致超时，优化一下，因为是三元组，所以最多只能选 `3` 个数，就是说 `map` 缓存的下标数最多只有 `3` 个，这优化勉强能通过，但耗时比较多。再次进行优化，从数组入手，先将数组排序，然后超过 `3` 个的重复元素将他删除，只保留 `3` 个，再利用之前的方法查询，耗时有明显下降。

最后利用双指针，先将数组排序，要 `a + b + c = 0`，相当于`-a = b + c`，第一层循环寻找寻找 `a`,若 `a` 与它上一个元素值相同，那么结果必然相同，可以直接跳过，之后遍历寻找 `b + c = -a` 的组合，由于数组有序，`b` 增加时，`c` 必然会减少，所以 `b` 从 `a` 的下标`+1` 开始遍历，`c` 从数组尾部开始遍历，当 `b + c > -a` 时，`c` 往前移，直到 `b + c <= -a` 或者 `b` 与 `c` 的指针重合，若寻找到合适的数值，则添加到结果集中。

## 解答

:::: code-group
::: code-group-item 暴力（超时）

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const idxs = map.get(num) || []
    idxs.push(i)
    map.set(num, idxs)
  }
  const set = new Set()
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const target = -(nums[i] + nums[j])
      const idxs = map.get(target)
      if (idxs) {
        idxs.forEach((idx) => {
          if (idx !== i && idx !== j) {
            set.add([nums[i], nums[j], nums[idx]].sort((a, b) => a - b).join(','))
          }
        })
      }
    }
  }
  return Array.from(set).map((i) => i.split(','))
}
```

:::
::: code-group-item 暴力（优化）

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const idxs = map.get(num) || []
    if (idxs.length < 3) {
      idxs.push(i)
    }
    map.set(num, idxs)
  }
  const set = new Set()
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const target = -(nums[i] + nums[j])
      const idxs = map.get(target)
      if (idxs) {
        idxs.forEach((idx) => {
          if (idx !== i && idx !== j) {
            set.add([nums[i], nums[j], nums[idx]].sort((a, b) => a - b).join(','))
          }
        })
      }
    }
  }
  return Array.from(set).map((i) => i.split(','))
}
```

:::
::: code-group-item 排序去重暴力

```javascript
/**
 * 排序去重暴力查询
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  nums = nums.sort((a, b) => a - b)
  let count = 1
  let pre = nums[0]
  for (let i = 1; i < nums.length; i++) {
    const num = nums[i]
    if (num === pre) {
      count++
    } else {
      pre = num
      count = 1
    }
    if (count === 4) {
      nums.splice(i, 1)
      count--
      i--
    }
  }
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const idxs = map.get(num) || []
    if (idxs.length < 3) {
      idxs.push(i)
    }
    map.set(num, idxs)
  }
  const set = new Set()
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const target = -(nums[i] + nums[j])
      const idxs = map.get(target)
      if (idxs) {
        idxs.forEach((idx) => {
          if (idx !== i && idx !== j) {
            set.add([nums[i], nums[j], nums[idx]].sort((a, b) => a - b).join(','))
          }
        })
      }
    }
  }
  return Array.from(set).map((i) => i.split(','))
}
```

:::
::: code-group-item 双指针

```javascript
/**
 * 双指针
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  const n = nums.length
  nums = nums.sort((a, b) => a - b)
  const ans = []
  for (let first = 0; first < n; first++) {
    if (first > 0 && nums[first] === nums[first - 1]) {
      continue
    }
    let third = n - 1
    const target = -nums[first]
    for (let second = first + 1; second < n; second++) {
      if (second > first + 1 && nums[second] === nums[second - 1]) {
        continue
      }
      while (second < third && nums[second] + nums[third] > target) {
        third--
      }
      if (second === third) {
        break
      }
      if (nums[second] + nums[third] === target) {
        ans.push([nums[first], nums[second], nums[third]])
      }
    }
  }
  return ans
}
```

:::
::::
