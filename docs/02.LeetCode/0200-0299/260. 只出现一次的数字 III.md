---
id: 3C821C72A0A28B29
title: 260、只出现一次的数字 III
date: 2022-01-09 21:58:01
permalink: /leetcode/single-number-iii
link: https://leetcode-cn.com/problems/single-number-iii
toc: false
categories:
  - LeetCode
tags:
  - 位运算
  - 数组
---

<Level type='medium'/>

## 题目

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

## 示例

示例 1：

```text
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

示例 2：

```text
输入：nums = [-1,0]
输出：[-1,0]
```

示例 3：

```text
输入：nums = [0,1]
输出：[1,0]
```

## 提示

- 2 <= nums.length <= 3 \* 10<sup>4</sup>
- -2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1
- 除两个只出现一次的整数外，nums 中的其他数字都出现两次

**进阶**：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

## 分析

- 词频统计

  - 利用 `map` 记录数字个数，找出结果为 `1` 的值。

- 位运算
  计算数组中的数的异或值，结果肯定是这两个数的异或值，因为这两个数必定不一样，所以异或结果必定不为 `0`，然后找出这个值的最低的 `1`，异或为 `1`，说明这两个数中有一个这个位是 `0`，有一个数这个位是 `1`，然后按位分组进行异或，得到最终结果就是这两个值。

## 解答

:::: code-group
::: code-group-item 词频统计

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
  const map = new Map()
  for (const num of nums) {
    map.set(num, (map.get(num) || 0) + 1)
  }
  const ans = []
  for (const [num, count] of map.entries()) {
    if (count === 1) {
      ans.push(num)
    }
  }
  return ans
}
```

:::
::: code-group-item 位运算

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
  let xSum = 0
  for (const num of nums) {
    xSum ^= num
  }
  const m = xSum & -xSum
  let a = 0,
    b = 0
  for (const num of nums) {
    if (num & m) {
      a ^= num
    } else {
      b ^= num
    }
  }
  return [a, b]
}
```

:::
::::
