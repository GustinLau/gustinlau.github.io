---
id: C84EA76047B9BDF9
title: 235、二叉搜索树的最近公共祖先
date: 2021-12-02 19:10:48
permalink: /leetcode/lowest-common-ancestor-of-a-binary-search-tree
link: https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree
toc: false
categories:
  - LeetCode
tags:
  - 树
  - 深度优先搜索
  - 搜索二叉树
  - 二叉树
---

<Level type='easy'/>

给定一个二叉搜索树， 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin) 中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![示例](/img/leetcode/0200-0299/235.1.png)

## 示例

示例 1:

```text
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

示例 2:

```text
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**说明**:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

## 分析

一种简单的想法是先搜索一遍，找出两个节点的所有祖先节点，再次遍历找出深度最大的。其次，还可以充分利用搜索二叉树的特性，一次遍历找出。

## 解答

:::: code-group
::: code-group-item 队列

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
  const ancestors = []
  const queue = []
  queue.push(root)
  while (queue.length) {
    const node = queue.shift()
    if (node.val === p.val) {
      queue.splice(queue.length)
    } else {
      if (node.val > p.val) {
        queue.push(node.left)
      } else {
        queue.push(node.right)
      }
    }
    ancestors.push(node)
  }
  let ans
  queue.push(root)
  while (queue.length) {
    const node = queue.shift()
    if (node.val === q.val) {
      if (ancestors.length && node.val === ancestors[0].val) {
        ans = ancestors.shift()
      }
      queue.splice(queue.length)
    } else {
      if (node.val > q.val) {
        queue.push(node.left)
      } else {
        queue.push(node.right)
      }
      if (ancestors.length && node.val === ancestors[0].val) {
        ans = ancestors.shift()
      } else {
        break
      }
    }
  }
  return ans ? ans : ancestors.shift()
}
```

:::
::: code-group-item 一次遍历+队列

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
  const ancestorsP = []
  const ancestorsQ = []
  const queueP = [root]
  const queueQ = [root]
  while (queueP.length || queueQ.length) {
    if (queueP.length) {
      const node = queueP.shift()
      if (node.val === p.val) {
        queueP.splice(queueP.length)
      } else {
        if (node.val > p.val) {
          queueP.push(node.left)
        } else {
          queueP.push(node.right)
        }
      }
      ancestorsP.push(node)
    }
    if (queueQ.length) {
      const node = queueQ.shift()
      if (node.val === q.val) {
        queueQ.splice(queueQ.length)
      } else {
        if (node.val > q.val) {
          queueQ.push(node.left)
        } else {
          queueQ.push(node.right)
        }
      }
      ancestorsQ.push(node)
    }
  }
  const length = Math.min(ancestorsP.length, ancestorsQ.length)
  let ans
  for (let i = 0; i < length; i++) {
    if (ancestorsQ[i].val === ancestorsP[i].val) {
      ans = ancestorsQ[i]
    } else {
      break
    }
  }
  return ans
}
```

:::
::: code-group-item 一次遍历

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {
  let ancestor = root
  while (true) {
    if (ancestor.val < p.val && ancestor.val < q.val) {
      ancestor = ancestor.right
    } else if (ancestor.val > p.val && ancestor.val > q.val) {
      ancestor = ancestor.left
    } else {
      break
    }
  }
  return ancestor
}
```

:::
::::
