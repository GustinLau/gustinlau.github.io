---
id: 6A72BAD4E0CB9A7B
title: 211、添加与搜索单词 - 数据结构设计
date: 2022-04-22 17:11:51
permalink: /leetcode/design-add-and-search-words-data-structure
link: https://leetcode-cn.com/problems/design-add-and-search-words-data-structure
toc: false
categories:
  - LeetCode
tags:
  -
---

<Level type='medium'/>

## 题目

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个. 都可以表示任何一个字母。

## 示例

示例：

```text
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
```

## 提示

- 1 <= word.length <= 25
- addWord 中的 word 由小写英文字母组成
- search 中的 word 由 '.' 或小写英文字母组成
- 最多调用 10<sup>4</sup> 次 addWord 和 search

## 分析

一种比较好的方法是使用前缀树，解答的思路与之类似，但有比较多的重复数据。

## 解答

```javascript
var WordDictionary = function () {
  this.map = new Map()
}

/**
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function (word) {
  const arr = word.split('')
  const length = arr.length
  let pre = this.map
  for (let i = 0; i < arr.length; i++) {
    const char = arr[i]
    if (!pre.has(char + '_' + (length - i))) {
      pre.set(char + '_' + (length - i), new Map())
    }
    pre = pre.get(char + '_' + (length - i))
  }
}

/**
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function (word) {
  const searchSub = (arr, map) => {
    if (!map) {
      return false
    }
    if (arr && arr.length) {
      const char = arr[0]
      const length = arr.length
      if (char !== '.') {
        const next = map.get(char + '_' + length)
        if (!next) {
          return false
        }
        return searchSub(arr.slice(1), next)
      } else {
        const keys = [...map.keys()]
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i].split('_')[0] + '_' + arr.length
          if (searchSub(arr.slice(1), map.get(key))) {
            return true
          }
        }
        return false
      }
    }
    return true
  }
  return searchSub(word.split(''), this.map)
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

```javascript
var WordDictionary = function () {
  this.trieRoot = new TrieNode()
}

WordDictionary.prototype.addWord = function (word) {
  this.trieRoot.insert(word)
}

WordDictionary.prototype.search = function (word) {
  const dfs = (index, node) => {
    if (index === word.length) {
      return node.isEnd
    }
    const ch = word[index]
    if (ch !== '.') {
      const child = node.children[ch.charCodeAt() - 'a'.charCodeAt()]
      if (child && dfs(index + 1, child)) {
        return true
      }
    } else {
      for (const child of node.children) {
        if (child && dfs(index + 1, child)) {
          return true
        }
      }
    }
    return false
  }
  return dfs(0, this.trieRoot)
}

class TrieNode {
  constructor() {
    this.children = new Array(26).fill(0)
    this.isEnd = false
  }

  insert(word) {
    let node = this
    for (let i = 0; i < word.length; i++) {
      const ch = word[i]
      const index = ch.charCodeAt() - 'a'.charCodeAt()
      if (node.children[index] === 0) {
        node.children[index] = new TrieNode()
      }
      node = node.children[index]
    }
    node.isEnd = true
  }

  getChildren() {
    return this.children
  }

  isEnd() {
    return this.isEnd
  }
}
```
