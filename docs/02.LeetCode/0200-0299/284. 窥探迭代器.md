---
id: 9EB8CCD5D3352178
title: 284、窥探迭代器
date: 2021-12-02 19:10:48
permalink: /leetcode/peeking-iterator
link: https://leetcode-cn.com/problems/peeking-iterator
toc: false
categories:
  - LeetCode
tags:
  - 设计
  - 数组
  - 迭代器
---

<Level type='medium'/>

## 题目

请你在设计一个迭代器，在集成现有迭代器拥有的  `hasNext` 和 `next` 操作的基础上，还额外支持 `peek` 操作。

实现 `PeekingIterator` 类：

- `PeekingIterator(Iterator<int> nums)` 使用指定整数迭代器  `nums` 初始化迭代器。
- `int next()` 返回数组中的下一个元素，并将指针移动到下个元素处。
- `bool hasNext()` 如果数组中存在下一个元素，返回 `true` ；否则，返回 `false` 。
- `int peek()` 返回数组中的下一个元素，但 **不** 移动指针。

**注意**：每种语言可能有不同的构造函数和迭代器  `Iterator`，但均支持 `int next()` 和 `boolean hasNext()` 函数。

## 示例

示例 1：

<div class="language-text extra-class">
<pre class="language-text">
<code>输入：
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
输出：
[null, 1, 2, 2, 3, false]
<div></div>
解释：
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<b style="text-decoration: underline">1</b>,2,3]
peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,<b style="text-decoration: underline">2</b>,3]
peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,<b style="text-decoration: underline">2</b>,3]
peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,<b style="text-decoration: underline">3</b>]
peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]
peekingIterator.hasNext(); // 返回 False</code>
</pre>
</div>

## 提示

- 1 <= nums.length <= 1000
- 1 <= nums[i] <= 1000
- 对 next 和 peek 的调用均有效
- next、hasNext 和 peek 最多调用 1000 次

**进阶**：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？

## 分析

添加一个缓冲区，执行 `peek` 的时候将 `next` 的返回放入缓冲区，`next` 与 `hasNext` 操作加入缓冲区是否为空判断。

## 解答

```javascript
/**
 * // This is the Iterator's API interface.
 * // You should not implement it, or speculate about its implementation.
 * function Iterator() {
 *    @ return {number}
 *    this.next = function() { // return the next number of the iterator
 *       ...
 *    };
 *
 *    @return {boolean}
 *    this.hasNext = function() { // return true if it still has numbers
 *       ...
 *    };
 * };
 */

/**
 * @param {Iterator} iterator
 */
var PeekingIterator = function (iterator) {
  this.buffer = []
  this.iterator = iterator
}

/**
 * @return {number}
 */
PeekingIterator.prototype.peek = function () {
  if (this.buffer.length === 0) {
    this.buffer.push(this.iterator.next())
  }
  return this.buffer[0]
}

/**
 * @return {number}
 */
PeekingIterator.prototype.next = function () {
  if (this.buffer.length > 0) {
    return this.buffer.shift()
  }
  return this.iterator.next()
}

/**
 * @return {boolean}
 */
PeekingIterator.prototype.hasNext = function () {
  return this.buffer.length > 0 || this.iterator.hasNext()
}

/**
 * Your PeekingIterator object will be instantiated and called as such:
 * var obj = new PeekingIterator(arr)
 * var param_1 = obj.peek()
 * var param_2 = obj.next()
 * var param_3 = obj.hasNext()
 */
```
