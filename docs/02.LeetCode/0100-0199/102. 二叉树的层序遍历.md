---
id: EBD41CEE0498C3AA
title: 102、二叉树的层序遍历
date: 2022-04-22 09:09:23
permalink: /leetcode/binary-tree-level-order-traversal
link: https://leetcode-cn.com/problems/binary-tree-level-order-traversal
toc: false
categories:
  - LeetCode
tags:
  - 树
  - 广度优先搜索
  - 二叉树
---

<Level type='medium'/>

## 题目

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

## 示例

示例 1

![示例 1](/img/leetcode/0100-0199/102.1.png)

```text
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

示例 2：

```text
输入：root = [1]
输出：[[1]]
```

示例 3：

```text
输入：root = []
输出：[]
```

## 分析

使用队列记录节点信息与层级信息。

## 解答

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  if (!root) {
    return []
  }
  const ans = []
  const queue = [{ level: 0, node: root }]
  while (queue.length) {
    const { level, node } = queue.shift()
    if (!ans[level]) {
      ans[level] = []
    }
    ans[level].push(node.val)
    if (node.left) {
      queue.push({ level: level + 1, node: node.left })
    }
    if (node.right) {
      queue.push({ level: level + 1, node: node.right })
    }
  }
  return ans
}
```
