---
id: D47639E2D5FB5759
title: 108、将有序数组转换为二叉搜索树
date: 2022-04-22 10:59:16
permalink: /leetcode/convert-sorted-array-to-binary-search-tree
link: https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree
toc: false
categories:
  - LeetCode
tags:
  - 树
  - 二叉搜索树
  - 数组
  - 分治
  - 二叉树
---

<Level type='easy'/>

## 题目

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

## 示例

示例 1：

![示例 1](/img/leetcode/0100-0199/108.1.png)

```text
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

![示例 1](/img/leetcode/0100-0199/108.2.png)

示例 2：

![示例 2](/img/leetcode/0100-0199/108.3.png)

```text
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

## 提示

- 1 <= nums.length <= 10<sup>4</sup>
- -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
- nums 按 严格递增 顺序排列

## 分析

高度平衡二叉搜索树的根节点是中间的数，分开左右两个，递归生成合并子树。

## 解答

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {
  if (nums.length === 0) {
    return null
  }
  const mid = Math.floor(nums.length / 2)
  return new TreeNode(
    nums[mid],
    sortedArrayToBST(nums.slice(0, mid)),
    sortedArrayToBST(nums.slice(mid + 1, nums.length))
  )
}
```
