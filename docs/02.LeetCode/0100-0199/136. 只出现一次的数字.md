---
id: 269634BD8D385B56
title: 136、只出现一次的数字
date: 2022-04-22 15:06:01
permalink: /leetcode/single-number
link: https://leetcode-cn.com/problems/single-number
toc: false
categories:
  - LeetCode
tags:
  - 位运算
  - 数组
---

<Level type='easy'/>

## 题目

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明**：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

## 示例

示例 1:

```text
输入: [2,2,1]
输出: 1
```

示例 2:

```text
输入: [4,1,2,1,2]
输出: 4
```

## 分析

排序后遍历对比或者使用 `Map` 和队列记录，异或运算，因为 `n ^ n => 0` ， `n ^ 0 = n` ，`a ^ b ^ c = a ^ c ^ b`

## 解答

:::: code-group
::: code-group-item 数学

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  return nums.reduce((ans, num) => ans ^ num, 0)
}
```

:::
::: code-group-item 排序对比

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) {
      i++
    } else {
      return nums[i]
    }
  }
}
```

:::
::: code-group-item 哈希表+队列

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  const map = new Map()
  const queue = []
  for (const num of nums) {
    map.set(num, (map.get(num) || 0) + 1)
    if (map.get(num) > 1) {
      while (queue.length) {
        const n = queue[0]
        if (map.get(n) > 1) {
          queue.shift()
        } else {
          break
        }
      }
    } else {
      queue.push(num)
    }
  }
  return queue[0]
}
```

:::
::::
