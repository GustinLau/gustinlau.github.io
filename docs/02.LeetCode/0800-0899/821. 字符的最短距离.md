---
id: C784F8E782DB8064
title: 821、字符的最短距离
date: 2022-04-19 20:23:26
permalink: /leetcode/shortest-distance-to-a-character
link: https://leetcode-cn.com/problems/shortest-distance-to-a-character
toc: false
categories:
  - LeetCode
tags:
  - 数组
  - 双指针
  - 字符串
---

<Level type='easy'/>

## 题目

给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。

返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。

两个下标  `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。

## 示例

示例 1：

```text
输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
```

示例 2：

```text
输入：s = "aaab", c = "b"
输出：[3,2,1,0]
```

## 提示

- 1 <= s.length <= 10<sup>4</sup>
- s[i] 和 c 均为小写英文字母
- 题目数据保证 c 在 s 中至少出现一次

## 分析

### 正向遍历+反向遍历

正向遍历，不断累加记录，遇到相同字符时重置为 0，这样可以保证目标字符右边的部分数据是正确的，然后反向遍历，同样不断累加，与之前的记录相比较，取较小的值，对旧记录进行修正，两次遍历后能得到正确答案。

### 滑动窗口

一次遍历统计个目标字符串的位置，第二次遍历开始计算位置值，若计算得到的最小值所使用的位置值发生改变，向右滑动窗口，因为上一个位置值已经无效。

## 解答

:::: code-group
::: code-group-item 双向遍历

```javascript
/**
 * @param {string} s
 * @param {string} c
 * @return {number[]}
 */
var shortestToChar = function (s, c) {
  const n = s.length
  const ans = new Array(s.length)
  let curr = n
  for (let i = 0; i < n; i++) {
    if (s[i] === c) {
      curr = 0
    }
    ans[i] = curr++
  }
  curr = n
  for (let i = n - 1; i > -1; i--) {
    if (s[i] === c) {
      curr = 0
    }
    ans[i] = Math.min(ans[i], curr++)
  }
  return ans
}
```

:::
::: code-group-item 滑动窗口

```javascript
/**
 * @param {string} s
 * @param {string} c
 * @return {number[]}
 */
var shortestToChar = function (s, c) {
  const n = s.length
  const ans = new Array(s.length).fill(Infinity)
  let cache = []
  for (let i = 0; i < n; i++) {
    if (s[i] === c) {
      ans[i] = 0
      cache.push(i)
    }
  }
  let start = 0
  for (let i = 0; i < n; i++) {
    if (s[i] !== c) {
      let min = n
      for (let j = start; j < cache.length; j++) {
        const abs = Math.abs(i - cache[j])
        if (abs < min) {
          start = j
          min = abs
        } else {
          break
        }
      }
      ans[i] = min
    }
  }
  return ans
}
```

:::
::::
