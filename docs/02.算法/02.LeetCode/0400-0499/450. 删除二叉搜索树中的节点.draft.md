---
id: 1C6466C931003F58
title: LC 450. 删除二叉搜索树中的节点
date: 2022-06-02 16:33:55
permalink: /algorithm/leetcode/delete-node-in-a-bst
link: https://leetcode.cn/problems/delete-node-in-a-bst
categories:
  - 算法
  - LeetCode
tags:
  - 树
  - 二叉树
---

<Level :type='2'/>

## 问题描述

给定一个二叉搜索树的根节点 `root` 和一个值 `key`，删除二叉搜索树中的 `key` 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

示例 1:

输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。

示例 2:

```text
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

示例 3:

```text
输入: root = [], key = 0
输出: []
```

提示:

- 节点数的范围 <code>[0, 10<sup>4</sup>]</code>
- <code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code>
- 节点值唯一
- `root` 是合法的二叉搜索树
- <code>-10<sup>5</sup> <= key <= 10<sup>5</sup></code>

进阶： 要求算法时间复杂度为 `O(h)`，`h` 为树的高度。

## 递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function (root, key) {
  if (!root) return null
  if (root.val === key) {
    if (!root.left) return root.right
    if (!root.right) return root.left
    let node = root.right
    while (node.left) {
      node = node.left
    }
    node.left = root.left
    return root.right
  } else if (root.val > key) {
    root.left = deleteNode(root.left, key)
  } else {
    root.right = deleteNode(root.right, key)
  }
  return root
}
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

## 迭代

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function (root, key) {
  if (!root) return null
  const head = new TreeNode(Infinity, root, null)
  const queue = [head]
  while (queue.length) {
    const node = queue.shift()
    let target = null
    if (node.left && node.left.val === key) {
      target = node.left
    } else if (node.right && node.right.val === key) {
      target = node.right
    }
    if (target) {
      if (target.right) {
        let successor = target.right
        while (successor.left) {
          successor = successor.left
        }
        successor.left = target.left
      } else {
        target.right = target.left
      }
      if (node.left === target) {
        node.left = target.right
      } else {
        node.right = target.right
      }
    } else {
      if (node.left && node.val > key) queue.push(node.left)
      if (node.right && node.val < key) queue.push(node.right)
    }
  }
  return head.left
}
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
